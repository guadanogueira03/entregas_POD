# -*- coding: utf-8 -*-
"""LISTO TP1 FUENTE DE DATOS - TEMPLATE.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1xEOevWH9d6YbtuGZT1kbu-e3fZ8t6Kv7

*   **Año:** 2024
*   **Alumno/a:** Guadalupe Nogueira
*   **Legajo:** 1203495

# Archivos de texto plano

[gutenberg.org](https://www.gutenberg.org/) (llamado así por el inventor de la imprenta moderna) es el sitio web del Proyecto Gutenberg que se dedica a la distribución y creación de eBooks. En este sitio se encuentra el [Don Quijote](https://www.gutenberg.org/ebooks/14859). El Don Quijote se puede leer en diferentes formatos, ¿no? Para la tarea, se va a usar el Don Quijote de texto plano. La siguiente celda descarga el .txt y lo guarda en el sistema para luego su futura lectura:
"""

!wget https://www.gutenberg.org/cache/epub/2000/pg2000.txt

"""## Consignas

***NOTA: Para estas consignas, no se puede usar modulos externos a Python***

Del archivo descargado, calcular la cantidad de lineas:
"""

libro = "pg2000.txt"
arch = open(libro,"r")
lineas = arch.readlines()
arch.close()
cant = len(lineas)
cant

"""Del archivo descargado, calcular la cantidad de veces que se dice:
*   'Quijote'
*   'mancha'
*   'españa'

Considerar que, por ejemplo, 'QuiJoTe' es lo mismo que 'quijote' (no *case sensitive*).
"""

contQ = 0
for linea in lineas:
  res = linea.lower()
  lista = res.split(" ")
  for pal in lista:
    if pal == "quijote" or pal == "quijote\n" or pal == "quijote," or pal == "quijote." or pal == "quijote:":
      contQ += 1
print("La palabra Quijote aparece",contQ, "veces")

contM = 0
for linea in lineas:
  res = linea.lower()
  lista = res.split(" ")
  for pal in lista:
    if pal == "mancha":
      contM += 1
print("La palabra Mancha aparece",contM, "veces")

contE = 0
for linea in lineas:
  res = linea.lower()
  lista = res.split(" ")
  for pal in lista:
    if pal == "españa":
      contE += 1
print("La palabra España aparece",contE, "veces")

"""¿Quien es el autor y titulo del libro? Responderlo usando las herramientas utilizadas en la celda anterior (Tip: abrir el archivo de texto y ver como son las primeras lineas)."""

# El author es nombrado en la linea 12
linea12 = lineas[12]
res = linea12.split(" ")
autor = (res[1:5])
pal = ""
for elem in autor:
  pal += elem
  pal += " "

print(pal)

# El titulo es nombrado en la linea 10
linea10 = lineas[10]
res = linea10.split(" ")
titulo = (res[1:5])
pal = ""
for elem in titulo:
  pal += elem
  pal += " "

print(pal)

"""# Archivos .csv

*Robert* De Niro actuó en mas de 100 peliculas y Rotten Tomatoes es un sitio web en el que se pueden leer criticas y ratings a peliculas hechos por críticos y usuarios. La siguiente linea descarga un archivo .csv en el que tenemos peliculas de De Niro junto a su rating en Rotten Tomatoes:
"""

!wget https://people.sc.fsu.edu/~jburkardt/data/csv/deniro.csv

"""## Consignas

***NOTA: Apartir de aca, se pueden usar modulos externos de Python***

Sabemos que el archivo tiene en su primera linea los 'headers'. ¿Cuales son? Imprimirlos.
"""

archivo = "deniro.csv"
arch = open(archivo,"r")
lineas = arch.readlines()
arch.close()

headers = lineas[0]
lista = headers.split(",")
for head in lista:
  pal = head.strip()
  print(pal)

"""Convertir la información del archivo .csv a un diccionario."""

import csv

peliculas = {}

with open(archivo, mode="r", encoding="utf-8") as file:
    csv_reader = csv.DictReader(file)
    for row in csv_reader:
        title = row[' "Title"']
        peliculas[title] = {key: value for key, value in row.items() if key != ' "Title"'}

print(peliculas)

"""¿Cuantas peliculas hay registradas en el archivo .csv?"""

cant = len(lineas) - 1

print("Hay", cant, "películas registradas en el archivo")

"""Imprimir las peliculas mejor y peor rankeadas del archivo (imprimir sus respectivos rankings)"""

import csv

peliculas = []

with open("deniro.csv", mode="r", encoding="utf-8") as file:
    csv_reader = csv.DictReader(file)
    for row in csv_reader:
        try:
            row[' "Score"'] = int(row[' "Score"'])
            peliculas.append(row)
        except ValueError:
            continue

mejor = max(peliculas, key=lambda x: x[' "Score"'])
peor = min(peliculas, key=lambda x: x[' "Score"'])

# Imprimir los resultados
print("Película mejor rankeada:")
print("Título:", mejor[' "Title"'])
print("Puntaje:", mejor[' "Score"'])


print("Película peor rankeada:")
print("Título:", peor[' "Title"'])
print("Puntaje:", peor[' "Score"'])

"""# Base de datos - Relacionales

SQLite es una biblioteca de C que provee una base de datos ligera basada en disco que no requiere un proceso de servidor separado y permite acceder a la base de datos usando una variación no estándar del lenguaje de consulta SQL. Algunas aplicaciones pueden usar SQLite para almacenamiento interno. También es posible prototipar una aplicación usando SQLite y luego transferir el código a una base de datos más grande como PostgreSQL u Oracle.

Realizamos el `import` e indicamos el archivo en el que vamos a guardar la base de datos:
"""

import sqlite3
conn = sqlite3.connect('db.db')

"""La siguiente linea de codigo agrega filas a la misma. Por favor, ejecutar la siguiente celda para la consigna:


"""

!wget https://people.sc.fsu.edu/~jburkardt/data/csv/snakes_count_10000.csv

cur = conn.cursor()
cur.execute("CREATE TABLE t (GameNumber, GameLength);")

with open('snakes_count_10000.csv','r') as csv_file:
  lines = csv_file.readlines()[1:]
  lines = [l.split(',') for l in lines]
  to_db = [(l[0].strip(), l[1].strip()) for l in lines]

cur.executemany("INSERT INTO t (GameNumber, GameLength) VALUES (?, ?);", to_db)
conn.commit()
conn.close()

"""## Consignas

¿Como luce la base de datos? Imprimirla.
"""

conn = sqlite3.connect('db.db')
cur = conn.cursor()
cur.execute("SELECT * FROM t")
rows = cur.fetchall()
for row in rows:
    print(row)
conn.close()

"""¿Cuantas filas hay en la base de datos?"""

conn = sqlite3.connect('db.db')
cur = conn.cursor()

cur.execute("SELECT COUNT(*) FROM t")
row_count = cur.fetchone()[0]

print(f"Número de filas en la base de datos: {row_count}")

conn.close()

"""¿Cual es el máximo `GameLength` y en qué `GameNumber` se realizó?"""

conn = sqlite3.connect('db.db')
cur = conn.cursor()


cur.execute("SELECT GameNumber, GameLength FROM t ORDER BY GameLength DESC LIMIT 1")
max_row = cur.fetchone()

print(f"El máximo GameLength es {max_row[1]} y se realizó en el GameNumber {max_row[0]}.")

conn.close()

"""# API Requests
Por lo general, conseguimos datos a traves de internet. Aunque el concepto de Application Programming Interface (API) es muy amplio y muy poco concreto, en el contexto de los servidores, es un conjunto de 'endpoints' que los servidores ofrecen para poder leer/procesar/escribir información en estos mismos.

[En este repositorio](https://github.com/public-apis/public-apis) van a encontrar una lista de APIs públicas (pueden elegir otras que no son de ese repositorio). Para la consigna, se recomienda usar aquellas APIs que no requieren autenticación. Si se elige una API con autenticación, por favor, adjuntar las keys o pasarl las credenciales necesarias para su futura ejecución También, pueden usar varias URLs.

## Consigna

Hacer una request GET e imprimir uno de los campos de la respuesta:
"""

import requests

url = "https://api.chucknorris.io/jokes/random"

response = requests.get(url)

data = response.json()
joke = data["value"]
print(f"Chiste de Chuck Norris: {joke}")

"""Hacer una request GET y, apartir de los campos en la respuesta, generar otro campo (por ejemplo, si la respuesta solo incluye un timestamp y una posición del registro, elaborar la velocidad del registro)"""

joke_id = data["id"]
joke_text = data["value"]

length_of_id = len(joke_id)

enhanced_data = { "joke_id": joke_id, "joke_text": joke_text, "length_of_id": length_of_id}

print("Datos con campo adicional:")
print(enhanced_data)

"""# Streaming data
Ahora vamos a hacer algo muy parecido a lo anterior, pero vamos a usar APIs que nos ofrecen datos en tiempo real. Pueden encontrar APIs de este estilo [en este repositorio](https://github.com/ColinEberhardt/awesome-public-streaming-datasets) (pueden elegir otras que no son de ese repositorio)

## Consigna

Hacer un plot con `matplotlib` de una variable de una API de datos streaming en el que el eje 'y' sea la variable y el eje 'x' el tiempo.
"""

import requests
import matplotlib.pyplot as plt
import time
from datetime import datetime

# URL de la API de OpenWeatherMap
API_KEY = '2260a8111a67bb31d68783023ab26ec1'
CITY = 'Buenos Aires'
URL = f'http://api.openweathermap.org/data/2.5/weather?q={CITY}&appid={API_KEY}&units=metric'

times = []
temperatures = []

# Configuración del gráfico
plt.ion()
fig, ax = plt.subplots()

for _ in range(20):  # Repetir 20 veces (por ejemplo, para 20 datos)
    try:

        response = requests.get(URL)
        response.raise_for_status()
        # Procesar los datos si la respuesta es exitosa
        data = response.json()

        # Extraer la temperatura y hora
        temperature = data['main']['temp']
        current_time = datetime.now().strftime('%H:%M:%S')

        # Agregar los datos a las listas
        times.append(current_time)
        temperatures.append(temperature)

        # Limpiar el gráfico y actualizar los datos
        ax.clear()
        ax.plot(times, temperatures, label='Temperatura (°C)', color='blue')

        # Configurar el gráfico
        ax.set_xlabel('Hora')
        ax.set_ylabel('Temperatura (°C)')
        ax.set_title('Temperatura en tiempo real')
        ax.legend()

        # Mostrar el gráfico
        plt.xticks(rotation=45)
        plt.tight_layout()
        plt.draw()

    except requests.exceptions.RequestException as e:

        print(f"Error en la solicitud: {e}")
        break  # Salir del ciclo si hay un error

    # Esperar 10 segundos antes de la siguiente solicitud
    time.sleep(10)

plt.ioff()
plt.show()